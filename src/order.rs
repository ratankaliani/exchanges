use std::ops::{Add, Sub};

/// Represents the side of an order - either a bid (buy) or ask (sell)
#[derive(Debug, Default, PartialEq, Eq, Clone, Copy)]
pub enum Side {
    #[default]
    Bid,
    Ask,
}

/// Represents a single order in the orderbook
#[derive(Debug, Default, Clone)]
pub struct Order {
    pub id: OrderId,
    pub price: Price,
    pub quantity: Quantity,
    pub side: Side,
    pub account_id: AccountId,
    pub timestamp: Timestamp,
}

impl Order {
    // TODO: OrderId should be generated by the exchange/market
    pub fn new(
        id: OrderId,
        price: Price,
        quantity: Quantity,
        side: Side,
        account_id: AccountId,
        timestamp: Timestamp,
    ) -> Self {
        Self {
            id,
            price,
            quantity,
            side,
            account_id,
            timestamp,
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AccountId(String);

impl AccountId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
}

#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct OrderId(u64);

impl OrderId {
    pub fn new(id: u64) -> Self {
        Self(id)
    }
}

#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Price(u64);

impl Price {
    pub fn new(price: u64) -> Self {
        Self(price)
    }

    pub fn get(&self) -> u64 {
        self.0
    }
}

#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NegatedPrice(u64);

impl NegatedPrice {
    pub fn new(price: u64) -> Self {
        Self(u64::MAX - price)
    }

    pub fn to_price(self) -> Price {
        Price::new(u64::MAX - self.0)
    }

    pub fn from_price(price: Price) -> Self {
        Self::new(price.get())
    }
}

#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Quantity(u64);

impl Quantity {
    pub fn new(quantity: u64) -> Self {
        Self(quantity)
    }
    pub fn get(&self) -> u64 {
        self.0
    }
}

impl Add for Quantity {
    type Output = Quantity;

    fn add(self, other: Quantity) -> Quantity {
        Quantity(self.get() + other.get())
    }
}

impl Sub for Quantity {
    type Output = Quantity;

    fn sub(self, other: Quantity) -> Quantity {
        Quantity(self.get() - other.get())
    }
}

#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Timestamp(u64);

impl Timestamp {
    pub fn new(timestamp: u64) -> Self {
        Self(timestamp)
    }
}

// /// Create an order with the given parameters.
// ///
// /// # Example
// ///
// /// ```
// /// let order = order!(1, 100, 10, Side::Bid, "trader1", 1);
// /// ```
// ///
// /// # Arguments
// ///
// /// * `id` - The unique identifier for the order.
// /// * `price` - The price of the order.
// /// * `qty` - The quantity of the order.
// /// * `side` - The side of the order.
// /// * `account` - The account of the order.
// /// * `ts` - The timestamp of the order.
// #[macro_export]
// macro_rules! create_order {
//     ($id:expr, $price:expr, $qty:expr, $side:expr, $account:expr, $ts:expr) => {
//         crate::order::Order {
//             id: crate::order::OrderId($id),
//             price: crate::order::Price($price),
//             quantity: crate::order::Quantity($qty),
//             side: $side,
//             account: $account.to_string(),
//             timestamp: crate::order::Timestamp($ts),
//         }
//     };
// }
